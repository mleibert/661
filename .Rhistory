knitr::opts_chunk$set(echo = TRUE)
str(diamonds)
library(ggplot2)
data("diamonds")
str(diamonds)
d <- ggplot(diamonds, aes(x= carat, y= price, colour= cut))
d+geom_point()
d <- ggplot(diamonds[1:1000,], aes(x= carat, y= price))
d + geom_point(aes(colour = cut))
d <- ggplot(diamonds, aes(price))
d + geom_density()
d + geom_density(aes(log10(price), colour = color))
ggplot(diamonds,aes(x= carat**.5, y= log10(price))) + geom_point() + geom_smooth(method = "lm")
ggplot(diamonds, aes(depth, colour = cut, fill =cut)) + geom_density(alpha =.2)+ xlim(55,70)
```{r, echo= FALSE}
ggplot(diamonds[diamonds$cut=="Fair",], aes(color, price)) +geom_boxplot(outlier.colour = "red", outlier.shape = 1) +labs(title="Fair cut diamonds")
d + geom_point(aes(colour = color, shape = cut))
ggplot(diamonds[sample(nrow(diamonds),2000),], aes(x= carat, y= log10(price))) + geom_point() + labs(title='log transformed scatter plot')
diamonds
require(ggplot2)
install.packages("ggplo2")
require(ggplot2)
diamonds
mean(diamonds[,1])
install.packages("knitr")
library(knitr)
install.packages("rmarkdown")
install.packages("rmarkdown")
require(rmarkdown)
---
title: "Lecture 7 Dataframes and ggplot2"
author: "Stuart Price"
date: "February 23, 2017"
output: html_document
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
## Lists
In R the list structure is similar to the Python dictionary structure. Lists are actually vectors (the type we have already learend are called *atomic* vectors)
```{r}
d <- list( key1 = "value1", key2 = 2, key3 = c(1,2,3))
```
How do we get the data?
```{r}
d[1]
d[[1]]
str(d[1])
str(d[[1]])
d$key1
d["key1"]
d[["key1"]]
```
What if we want to add data?
```{r}
d$key4 <- "value4"
d[[5]] <- 5
d[6:7] <- 6:7
```
What about deleting data?
```{r}
d[[6]] <- NULL
```
The functions lapply (for list apply) and sapply (simplified list apply) are very useful ways to apply a single function to every element of a list.
```{r}
lapply(d, length)
```
```{r}
sapply(d, length)
```
## Data Frames
A data frame is a special type of list where all the contents are vectors of the same length.
```{r}
a <- c("a", "b", "c")
b <- c(1, 2, 3)
c <- c(TRUE, FALSE, TRUE)
d <- data.frame(a,b,c)
```
```{r}
str(d$a)
str(d[1])
str(d[1,])
str(d[,1])
str(d[,1:2])
```
Some important features
```{r}
names(d)
# To Rename a column
names(d)[2] <- "New_Col_Name"
```
Assigning values
```{r}
d
d[2,2] <- 4
d
```
Warning: if you accidentally assign the wrong type of value to a column it will coerce the whole column into a more general type
```{r}
str(d)
d[3,3] <- 1
str(d)
```
Let's look at a built in data frame.
```{r}
data("iris")
```
```{r}
str(iris)
summary(iris)
```
An important task for statistics is taking a random sample of data. For this we use the sample() function.
```{r}
iris[sample(nrow(iris),10),]
```
Exercises:
- 1. What are the summary statistics for only the setosa iris?
- 2. What is the mean petal width for flowers with a petal length >= 1.5?
- 3. What are the species count for iris with greater petal and sepal length than the median?
- 4. What is the maximum petal width of rows not in the range 50 to 100 (inclusive)?
- 5. How many flowers have a sepal width of 2.5 or 3.0?
```{r}
summary(iris[iris$Species=="setosa",])
mean(iris[iris$Petal.Length >= 1.5,]$Petal.Width)
summary(subset(iris, Petal.Length > 1.5 & Sepal.Length >5))
max(iris[-(50:100),]$Petal.Width)
```
To start to get to know a data set try str() and summary()
```{r}
str(iris)
summary(iris)
```
## ggplot2
ggplot2 is a statistical graphics package by Hadley Wickham. It is based on a book `The Grammar of Graphics` and attempts to bring a standard method to making graphics.
"An abstraction which makes thinking, reasoning and communicating graphics easier"
https://www.rstudio.com/wp-content/uploads/2015/03/ggplot2-cheatsheet.pdf
Basic call is:
*ggplot()* # *g*rammar of *g*raphics *plot*
A plot is composed of several elements.
- data: A data frame containing the information to be plotted
- coordinate system: describes the space onto which the data is projected
- e.g. Cartesian coordinates or a map projection
- geoms: describes the geometric objects that are being used to represent the data (i.e. the type of plot)
- e.g. boxplot, bar, point, polygon, etc
- aesthetics: visual properties of the representation
- e.g. size, color, shape, transparency
- scales: control how the data is mapped to the aesthetic
- stat: an optional transformation to the data
- e.g. a regression line
- facets: an optional splitting of the data into subsets to be displayed across multiple graphs
```{r}
library(ggplot2)
data("diamonds")
str(diamonds)
```
## Example: Scatter plot of carat vs price
- data: diamonds data, particularly carat and price
- coordinate system: Cartesian coordinates
- geoms: Scatter plots use points
- scale: Default is linear scaling, but could use log (as is often a good idea for monetary columns)
```{r}
d <- ggplot(data = diamonds, mapping = aes(x = carat, y = price))
#d <- ggplot(diamonds, aes(x = carat, y = price))
str(d)
```
This creates the basic ggplot object. Each layer added to this inherits defaults set in the base object, but the base values can be overwritten at any level.
aes() function describes relationship, doesn't supply data
```{r}
d + geom_point()
```
What if I want the color of the point to reflect the type of cut the diamond has?
```{r}
d + geom_point(aes(colour = cut))
```
Note that the same information could have been added to the aes() of the basic ggplot object.
```{r}
d <- ggplot(diamonds, aes(x= carat, y= price, colour= cut))
d+geom_point()
```
Note that sometimes using too many points can slow down plotting. So when working on getting formatting just right it is often useful to make sure that you limit the number of points that you are plotting.
```{r}
d <- ggplot(diamonds[1:1000,], aes(x= carat, y= price))
d + geom_point(aes(colour = cut))
```
Does anything seem weird about that graph? It is usually best to sample a dataframe instead of just taking a cut, since the data frame might be sorted.
```{r}
d <- ggplot(diamonds[sample(nrow(diamonds), 2000),], aes(x= carat, y= price))
d + geom_point(aes(colour = cut))
```
What if I want to add more information to my graph? Such as color of the diamond?
```{r}
d <- ggplot(diamonds[sample(nrow(diamonds), 2000),], aes(x= carat, y= price))
d + geom_point(aes(colour = cut, shape = color))
```
Notice the error messages. How about we try something slightly different.
```{r}
d + geom_point(aes(colour = color, shape = cut))
```
What if I wanted to change the scale of my y-axis?
```{r}
ggplot(diamonds[sample(nrow(diamonds),2000),], aes(x= carat, y= log10(price))) + geom_point() + labs(title='log transformed scatter plot')
```
What about a density function?
```{r}
d <- ggplot(diamonds, aes(price))
d + geom_density()
```
What if we want to shorten that tail?
```{r}
d + geom_density(aes(log10(price)))
```
What if we want to split the graph up by color?
```{r}
d + geom_density(aes(log10(price), colour = color))
```
What if that is too hard to read and we want multiple graphs?
```{r}
d + geom_density(aes(log10(price))) + facet_grid(~color)
```
```{r}
d + geom_density(aes(log10(price))) + facet_grid(cut~color)
```
Try to reproduce the following graphs:
```{r pressure, echo=FALSE}
ggplot(diamonds,aes(x= carat**.5, y= log10(price))) + geom_point() + geom_smooth(method = "lm")
```
```{r, echo= FALSE}
ggplot(diamonds, aes(depth, colour = cut, fill =cut)) + geom_density(alpha =.2)+ xlim(55,70)
```
```{r, echo= FALSE}
ggplot(diamonds[diamonds$cut=="Fair",], aes(color, price)) +geom_boxplot(outlier.colour = "red", outlier.shape = 1) +labs(title="Fair cut diamonds")
```
library("knitr", lib.loc="~/R/win-library/3.3")
knitr::opts_chunk$set(echo = TRUE)
## Lists
In R the list structure is similar to the Python dictionary structure. Lists are actually vectors (the type we have already learend are called *atomic* vectors)
rm(list = ls())
setwd("G:\\math\\661")
options(scipen=999)
library("VGAM")
rm(list = ls())
setwd("G:\\math\\661")
options(scipen=999)
library("VGAM")
library(MASS)
cheese<-read.table("cheese.txt",header=T)
polr.fit = polr(as.factor(response) ~ type, weights=count, data=cheese)
cheese.ungrp = as.data.frame(
lapply(cheese, function(x,p) rep(x,p), cheese$count))
tail(cheese);tail(cheese.ungrp )
cheese.ungrp <- cheese.ungrp[,-3] 
vglm.fit = vglm(response ~ type, 
family=cumulative(parallel=T), data=cheese.ungrp)
summary(vglm.fit)
summary( polr.fit  )
summary(vglm.fit)
cheese
summary(vglm.fit)
tail(cheese);tail(cheese.ungrp )
summary(vglm.fit)
tail(cheese);tail(cheese.ungrp )
summary(vglm.fit)
mental<-read.table("mental.txt",header=T)
mental
mental<-mental[,c(1,3,2)]
vglm(impair~ses+lifefamily=cumulative(parallel=T), data=mental)
summary(vglm.fit)
vglm(impair~ses+lifefamily=cumulative(parallel=T), data=mental)
vglm(impair~ses+life,family=cumulative(parallel=T), data=mental)
summary(vglm.fit)
mental.fit<-vglm(impair~ses+life ,family=cumulative(parallel=T), data=mental)
summary(mental.fit)
mental.fit<-vglm(impair~ses+life ,family=cumulative(parallel=F), data=mental)
summary(mental.fit)
mental.fit<-vglm(impair~ses+life ,family=cumulative, data=mental)
summary(mental.fit)
mental.fit<-vglm(impair~ses+life ,family=cumulative(parallel=F), data=mental)
summary(mental.fit)
-.319*.37+1.111
-.319*.37+1.111-.2818
-.319*4.3+1.111
-.319*4.3+1.111+1.2129
-.3189*4.3
-.3189*4.3+1.111
-.3189*4.3+1.111-.2818
summary(mental.fit)
mental.fit<-vglm(impair~ses+life ,family=cumulative(parallel=T), data=mental)
summary(mental.fit)
1.1112 + -0.3189 * 4.3
.37-
1.1112 + -0.3189 * 4.3
.37- -0.26007
1.1112 + -0.3189 * 4.3 -.2818
exp(1.1112 + -0.3189 * 4.3 -.2818)
predict(mental.fit,c(4.3,1) )
predict(mental.fit,newdata=c(4.3,1) )
mental.fit
1.1112 + -0.3189 * 4.3
-.2818 + -0.3189 * 4.3+ 1.1112 
exp( -.2818 + -0.3189 * 4.3+ 1.1112 ) 
exp( -.2818 + -0.3189 * 4.3+ 1.1112 * 0 ) 
exp( -.2818 + -0.3189 * 4.3+ 1.1112 * 1 + 1.2129 + 2.2095 ) 
exp( -.2818 + -0.3189 * 4.3+ 1.1112 * 1  ) 
exp( -.2818 ) + exp( -0.3189 * 4.3 ) + exp( 1.1112 * 1  ) 
exp( -.2818 ) * exp( -0.3189 * 4.3 ) * exp( 1.1112 * 1  ) 
exp( -0.3189 * 4.3 ) 
exp( -0.3189 * 4.3  +  1.1112 * 1  ) 
exp( -.2818 ) + exp( -0.3189 * 4.3  +  1.1112 * 1  ) 
mental
mental[2,]
men<-mental[2,]
men[,2]<-4.3
predict(mental.fit,newdata=men)
predict(mental.fit,newdata=men, response=T)
predict(mental.fit,newdata=men, response=F)
predict(mental.fit,newdata=men, type=("response"))
predict(mental.fit,newdata=men, type=("response"))
men[,3]<-0
predict(mental.fit,newdata=men, type=("response"))
mat<-matrix(NA,4,2)
mat[,1]<-c(1,1,88,16,2)
mat[,2]<-c(1, 0, 54, 7 ,5)
mat[,3]<-c(0 ,1, 397 ,141 ,24)
mat[,4]<-c(0 ,0 ,235, 189, 39)
mat<-matrix(NA,4,5)
mat[,1]<-c(1,1,88,16,2)
mat[,2]<-c(1, 0, 54, 7 ,5)
mat<-matrix(NA,4,5)
mat
mat<-matrix(NA,4,5)
mat[1,]<-c(1,1,88,16,2)
mat[2,]<-c(1, 0, 54, 7 ,5)
mat[3,]<-c(0 ,1, 397 ,141 ,24)
mat[4,]<-c(0 ,0 ,235, 189, 39)
mat
cheese
gender<-c("female","male")
gender<-c("female","male")
race<-c("black","white")
mylist<-list()
mlist<-list()
i=1
mat
mat[i,1]
race[ mat[i,1] ]
rep( race[ mat[i,1] ], sum(mat[i,-c(1,2)]) ) 
data.frame( rep( race[ mat[i,1] ], sum(mat[i,-c(1,2)]) ) , 
rep( gender[ mat[i,1] ], sum(mat[i,-c(1,2)]) ) ) 
mylist[[i]]<-data.frame( rep( race[ mat[i,1] ], sum(mat[i,-c(1,2)]) ) , 
rep( gender[ mat[i,1] ], sum(mat[i,-c(1,2)]) ) ) 
mylist
heaven<-c( "yes" , "unsure" , "no" )
mat
c(rep( mat[i,3] , heaven[1] ),rep( mat[i,4] ,
 heaven[1] ) ,rep( mat[i,5] , heaven[1] )  )
rep( mat[i,3] , heaven[1] )
 mat[i,3] 
 heaven[1]
rep( heaven[1], mat[i,3]  )
c( rep( heaven[1], mat[i,3]  ) , rep( heaven[1], mat[i,4]  ),
  rep( heaven[1], mat[i,5]  ) )
c( rep( heaven[1], mat[i,3]  ) , rep( heaven[2], mat[i,4]  ),
  rep( heaven[3], mat[i,5]  ) )
names(mylist[[i]])[1:2]
names(mylist[[i]])[1:2]<-c("race","gender")
mylist
mylist[[i]]$y<-c( rep( heaven[1], mat[i,3]  ) ,
 rep( heaven[2], mat[i,4]  ), rep( heaven[3], mat[i,5]  ) )
names(mylist[[i]])[1:2]<-c("race","gender")
mylist
mat<-matrix(NA,4,5)
mat[1,]<-c(1,1,88,16,2)
mat[2,]<-c(1, 0, 54, 7 ,5)
mat[3,]<-c(0 ,1, 397 ,141 ,24)
mat[4,]<-c(0 ,0 ,235, 189, 39)
mat
gender<-c("female","male")
race<-c("black","white")
heaven<-c( "yes" , "unsure" , "no" )
mylist<-list()
for( i in 1:4){
mylist[[i]]<-data.frame( rep( race[ mat[i,1] ], sum(mat[i,-c(1,2)]) ) , 
rep( gender[ mat[i,1] ], sum(mat[i,-c(1,2)]) ) ) 
mylist[[i]]$y<-c( rep( heaven[1], mat[i,3]  ) ,
 rep( heaven[2], mat[i,4]  ), rep( heaven[3], mat[i,5]  ) )
names(mylist[[i]])[1:2]<-c("race","gender") }
heaven<-do.call("rbind", mylist)
i
race[ mat[i,1] ]
 race[ mat[i,1] ]
mat<-matrix(NA,4,5)
mat[1,]<-c(1,1,88,16,2)
mat[2,]<-c(1, 2, 54, 7 ,5)
mat[3,]<-c(2 ,1, 397 ,141 ,24)
mat[4,]<-c(2 ,2 ,235, 189, 39)
mat
gender<-c("female","male")
race<-c("black","white")
heaven<-c( "yes" , "unsure" , "no" )
mylist<-list()
for( i in 1:4){
mylist[[i]]<-data.frame( rep( race[ mat[i,1] ], sum(mat[i,-c(1,2)]) ) , 
rep( gender[ mat[i,1] ], sum(mat[i,-c(1,2)]) ) ) 
mylist[[i]]$y<-c( rep( heaven[1], mat[i,3]  ) ,
 rep( heaven[2], mat[i,4]  ), rep( heaven[3], mat[i,5]  ) )
names(mylist[[i]])[1:2]<-c("race","gender") }
heaven<-do.call("rbind", mylist)
heaven
tail(heaven)
heaven.fit = vglm(y ~ race+gender, family=cumulative(parallel=T), data=heaven)
str(heaven)
heaven$y<-as.factor(heaven$y)
heaven.fit = vglm(y ~ race+gender, family=cumulative(parallel=T), data=heaven)
summary(vglm.fit)
summary(heaven.fit )
mental
str(mental)
heaven
str(heaven)
heaven$y<-as.numeric(heaven$y)
heaven
heaven[,1]<-as.numeric(heaven[,1])
heaven
heaven[,2]<-as.numeric(heaven[,2])
heaven.fit = vglm(y ~ race+gender, family=cumulative(parallel=T), data=heaven)
summary(heaven.fit )
heaven
heaven[,1] == 2
heaven[,1]<-ifelse(heaven[,1] == 2, heaven[,1]<-0,heaven[,1]<-1)
heaven
heaven[,2]<-ifelse(heaven[,2] == 2, heaven[,2]<-0,heaven[,2]<-1)
heaven.fit = vglm(y ~ race+gender, family=cumulative(parallel=T), data=heaven)
mat
mat<-as.data.frame(mat)
mat
names(mat)<-c("race","gender","y1","y2","y3")
mat
mat
mat<-matrix(NA,4,5)
mat[1,]<-c(1,1,88,16,2)
mat[2,]<-c(1, 0, 54, 7 ,5)
mat[3,]<-c(0 ,1, 397 ,141 ,24)
mat[4,]<-c(0 ,0 ,235, 189, 39)
mat
mat<-as.data.frame(mat)
names(mat)<-c("race","gender","y1","y2","y3")
mat
heaven.fit = vglm(cbind(y1,y2,y3)~gender+race, 
family=cumulative(parallel=T), data=heaven)
names(mat)<-c("race","gender","y1","y2","y3")
mat
heaven.fit = vglm(cbind(y1,y2,y3)~gender+race, 
family=cumulative(parallel=T), data=heaven)
mat
cbind(y1,y2,y3)
y1$mat
mat$y1
heaven.fit = vglm(cbind(mat$y1,mat$y2,mat$y3)~gender+race, 
family=cumulative(parallel=T), data=heaven)
heaven.fit = vglm(cbind(y1,y2,y3)~gender+race, 
family=cumulative(parallel=T), data=mat)
summary(heaven.fit )
q()
